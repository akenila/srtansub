def extract(path):
    with open(path, 'r', encoding="utf-8") as file:
        return json.load(file)

def write(data, filename):
    with open(filename, 'w', encoding="utf-8") as file:
        file.write(data)

def ms_to_srt(time_in_ms):
    convert_ms = int(time_in_ms / 1000)
    ms = convert_ms % 1000
    total_seconds = (convert_ms - ms) / 1000
    seconds = int(total_seconds % 60)
    total_minutes = (total_seconds - seconds) / 60
    minutes = int(total_minutes % 60)
    hour = int((total_minutes - minutes) / 60)

    return f'{hour:02}:{minutes:02}:{seconds:02},{ms:03}'

def scrap_subs(content):
    subtitles_info = []
    materials = content['materials']
    sub_timing = content['tracks'][1]['segments']

    for m in materials['texts']:
        content = json.loads(m['content'])['text']

        segment = next(seg for seg in sub_timing if seg['material_id'] == m['id'])
        start = segment['target_timerange']['start']
        end = start + segment['target_timerange']['duration']
        timestamp = f'{ms_to_srt(start)} --> {ms_to_srt(end)}'
        index = len(subtitles_info) + 1

        subtitles_info.append({
            'index': index,
            'timestamp': timestamp,
            'content': content
        })

    return subtitles_info

# CapCut interaction functions from extractsrt.py
def select_folder():
    """Open dialog to select folder with videos"""
    root = tk.Tk()
    root.withdraw()  # Hide the main window
    folder_path = filedialog.askdirectory(title="Select folder with videos")
    root.destroy()
    return folder_path

def get_video_files(folder_path):
    """Get list of video files from the folder"""
    video_extensions = ['.mp4', '.avi', '.mov', '.mkv', '.wmv']
    video_files = []
    
    for file in os.listdir(folder_path):
        if any(file.lower().endswith(ext) for ext in video_extensions):
            video_files.append(os.path.join(folder_path, file))
    
    return video_files

def open_capcut():
    """Open Capcut application or restore if minimized"""
    try:
        # Check if Capcut is already running
        capcut_windows = gw.getWindowsWithTitle("剪映专业版")
        
        if capcut_windows:
            # Capcut is already running
            capcut_window = capcut_windows[0]
            
            # Check if window is minimized
            if capcut_window.isMinimized:
                print("Restoring minimized Capcut window...")
                capcut_window.restore()
            
            # Activate and focus on the window
            capcut_window.activate()
            time.sleep(2)  # Wait for window to become active
            print("Capcut window activated")
            
        else:
            # Capcut is not running, launch it
            capcut_path = os.getenv("LOCALAPPDATA") + r"\JianyingPro\Apps\JianyingPro.exe"    
            subprocess.Popen(capcut_path)
            print("Opening Capcut...")
            time.sleep(5)  # Wait for Capcut to open
        
        return True
        
    except Exception as e:
        print(f"Error with Capcut: {e}")
        return False

def create_new_project(video_path):
    """Create a new project with the video"""
    try:
        # Click "New Project" button
        new_project_pos = pyautogui.locateCenterOnScreen('./assets/create_project.png', confidence=0.8)
        if new_project_pos:
            pyautogui.click(new_project_pos)
            time.sleep(2)
        else:
            print("Could not find New Project button")
            return False
        gw.getWindowsWithTitle("剪映专业版")[0].maximize()
        time.sleep(2)
            
        # Import video
        import_video_pos = pyautogui.locateCenterOnScreen('./assets/import_media.png', confidence=0.8)
        if import_video_pos:
            pyautogui.click(import_video_pos)
            time.sleep(1)
            
            # Type the path to the video file
            video_path = video_path.replace('/', '\\')  # Replace forward slashes with backslashes
            pyperclip.copy(video_path)  # Copy path to clipboard
            pyautogui.hotkey('ctrl', 'v')
            time.sleep(2)
            pyautogui.press('enter')
            
            time.sleep(3)
            
            # Get screen dimensions
            screen_width, screen_height = pyautogui.size()
            
            video_in_panel_pos = (screen_width * 0.1, screen_height * 0.19)
            
            # Define the drop target (timeline/lower half of app)
            drop_target = (screen_width * 0.5, screen_height * 0.75)
            
            # Perform the drag and drop
            pyautogui.moveTo(video_in_panel_pos)
            pyautogui.mouseDown()
            time.sleep(0.5)  # Brief pause before dragging
            pyautogui.moveTo(drop_target, duration=1.0)  # Slow drag movement
            pyautogui.mouseUp()
            time.sleep(2)  # Wait for the drop to be processed
        else:
            print("Could not find Import Media button")
            return False
            
        return True
    except Exception as e:
        print(f"Error creating new project: {e}")
        return False

def generate_auto_subtitles():
        # Click on Auto Captions or Subtitle button
        subtitle_pos = pyautogui.locateCenterOnScreen('./assets/subtitle.png', confidence=0.8)
        if subtitle_pos:
            pyautogui.click(subtitle_pos)
            time.sleep(2)
            
            # Click on Auto Captions
            auto_captions_pos = pyautogui.locateCenterOnScreen('./assets/auto_caption.png', confidence=0.8)
            if auto_captions_pos:
                pyautogui.click(auto_captions_pos)
                time.sleep(2)
                
                screen_width, screen_height = pyautogui.size()
                
                video_in_panel_pos = (screen_width * 0.1, screen_height * 0.23)
                pyautogui.click(video_in_panel_pos)
                time.sleep(2)
                capcut_path = os.getenv("LOCALAPPDATA") + r"\JianyingPro"
                projects_path = capcut_path + r"\User Data\Projects\com.lveditor.draft"
                print("Waiting for subtitles to generate...")
                while True:
                    try:
                        pyautogui.locateCenterOnScreen('./assets/loading.png', confidence=0.8)
                    except Exception as e:
                        break
                    time.sleep(5)
                time.sleep(2)
                return True
            else:
                print("Could not find Auto Captions button")
                return False
        else:
            print("Could not find Subtitle button")
            return False

def close_project():
    """Close the current project"""
    print("Closing project...")
    time.sleep(3)
    
    width, height = pyautogui.size()
    pyautogui.click(width*0.05, height*0.01)
    time.sleep(1)
    try:
        close = pyautogui.locateCenterOnScreen('./assets/back_home.png', confidence=0.7)
        if close:
                pyautogui.click(width*0.05, height*0.2)
                time.sleep(1)
        else:
            return close_project()
    except Exception as e:
        print(f"Failed to close project: {e}")
        return close_project()

def delete_folder(path):
    try:
        # Check if the path exists
        if not os.path.exists(path):
            print(f"Path does not exist: {path}")
            return None
            
        # Check if it's a file
        if os.path.isfile(path):
            os.remove(path)
            print(f"Removed file: {path}")
            return True
            
        # If it's a directory, process all contents first
        for item in os.listdir(path):
            item_path = os.path.join(path, item)
            
            # Recursively delete files and subdirectories
            delete_folder(item_path)
            
        # After all contents are deleted, remove the directory itself
        os.rmdir(path)
        print(f"Removed directory: {path}")
        return True
        
    except Exception as e:
        print(f"Error while deleting {path}: {e}")
        return False

def get_srt_file(video_name, output_folder="Capcut_SRT"):
    """Extract SRT file from CapCut project"""
    if not os.path.exists(output_folder):
        os.makedirs(output_folder)
    time.sleep(3)
    if not os.path.exists(output_folder):
        os.makedirs(output_folder)
    
    capcut_path = os.getenv("LOCALAPPDATA") + r"\JianyingPro"
    projects_path = capcut_path + r"\User Data\Projects\com.lveditor.draft"

    project = [p for p in os.listdir(projects_path) if p not in ['.recycle_bin', 'root_meta_info.json']][0]

    draft = fr"{projects_path}\{project}\draft_content.json"
    subtitles = scrap_subs(extract(draft))

    output = ''.join([f'{s["index"]}\n{s["timestamp"]}\n{s["content"]}\n\n' for s in subtitles])
    output_file = os.path.join(output_folder, f"{video_name}.srt")
    write(output, output_file)
    time.sleep(1)
    
    return output_file, output

def open_subtitle_edit(srt_file, status_label):
    """Open Subtitle Edit for all SRT files in the folder"""
    # Path to Subtitle Edit executable - ADJUST THIS PATH to your installation
    subtitle_edit_path = r"C:\Program Files\Subtitle Edit\SubtitleEdit.exe"
    
    # Get the absolute path to the SRT files folder
    status_label.config(text=f"Opening Subtitle Edit for {srt_file}...")
    name = os.path.basename(srt_file)
    
    if status_label:
        status_label.config(text=f"Opening Subtitle Edit for {name}...")
    
    # Launch Subtitle Edit and open the file
    name = os.path.basename(srt_file)
    subprocess.Popen([subtitle_edit_path, srt_file])
    while not gw.getWindowsWithTitle(f'{name} - Subtitle Edit'):
        time.sleep(1)
    gw.getWindowsWithTitle(f'{name} - Subtitle Edit')[0].maximize()
    screen_width, screen_height = pyautogui.size()
    tools_button = (screen_width*0.05, screen_height*0.03)
    pyautogui.click(tools_button)
    time.sleep(1)
    merge_button = (screen_width*0.05, screen_height*0.21)
    pyautogui.click(merge_button)
    time.sleep(1)
    pyautogui.hotkey('tab')
    pyautogui.hotkey('tab')
    pyautogui.hotkey('enter')
    pyautogui.hotkey('ctrl', 's')
    time.sleep(1)
    gw.getWindowsWithTitle(f'{name} - Subtitle Edit')[0].close()
    print(f"Subtitle Edit successfully saved the file: {srt_file}")
    
    return True
# Translation functions from UI.py
def split_chrome_profile_path(full_path):
    if not full_path:
        return None, None
        
    user_data_index = full_path.find("User Data")
    if user_data_index == -1:
        return full_path, "Default"
    
    user_data_dir = full_path[:user_data_index + len("User Data")]
    
    remaining = full_path[user_data_index + len("User Data"):]
    if remaining.startswith("\\") or remaining.startswith("/"):
        remaining = remaining[1:]
    
    profile_name = remaining if remaining else "Default"
    
    if "\\" in profile_name or "/" in profile_name:
        profile_name = profile_name.split("\\")[0].split("/")[0]
    
    return user_data_dir, profile_name

def select_output_folder(entry):
    folder_path = filedialog.askdirectory()
    if folder_path:
        entry.delete(0, tk.END)
        entry.insert(0, folder_path)

def select_profile_file(entry):
    file_path = filedialog.askopenfilename(filetypes=[("JSON files", "*.json")])
    if file_path:
        entry.delete(0, tk.END)
        entry.insert(0, file_path)

# Settings management
custom_settings = {}

def save_custom_settings(model_var, mapping_text, prompt_text):
    try:
        selected_model = model_var.get()
        if not selected_model:
            messagebox.showerror("Error", "Please select a model.")
            return

        mapping = {}
        for line in mapping_text.splitlines():
            if ":" in line:
                key, value = line.split(":", 1)
                mapping[key.strip()] = value.strip()

        global custom_settings
        custom_settings = {
            "model": selected_model,
            "mapping": mapping,
            "prompt": prompt_text.strip()
        }
        messagebox.showinfo("Success", "Settings saved successfully!")
    except Exception as e:
        messagebox.showerror("Error", f"Failed to save settings: {e}")

def save_settings_to_file(videos_folder_entry=None, output_folder_entry=None, api_var=None, api_key_entry=None, profile_entry=None, model_var=None, mapping_text=None):
    try:
        global custom_settings
        
        # Get existing settings or create new dict
        if not custom_settings:
            custom_settings = {}
        
        # Save all UI settings
        if videos_folder_entry:
            custom_settings["videos_folder"] = videos_folder_entry.get()
        
        if output_folder_entry:
            custom_settings["output_folder"] = output_folder_entry.get()
        
        if api_var:
            custom_settings["api_type"] = api_var.get()
        
        if api_key_entry:
            custom_settings["api_key"] = api_key_entry.get()
        
        if profile_entry:
            custom_settings["profile_path"] = profile_entry.get()
        
        if model_var:
            custom_settings["model"] = model_var.get()
        
        if mapping_text:
            mapping = {}
            for line in mapping_text.get("1.0", tk.END).splitlines():
                if ":" in line:
                    key, value = line.split(":", 1)
                    mapping[key.strip()] = value.strip()
            custom_settings["mapping"] = mapping
        
        # Save to file
        with open("mapping_settings.json", "w", encoding="utf-8") as f:
            json.dump(custom_settings, f, ensure_ascii=False, indent=4)
        messagebox.showinfo("Success", "Settings saved to mapping_settings.json")
    except Exception as e:
        messagebox.showerror("Error", f"Failed to save settings: {e}")

def load_settings_from_file():
    global custom_settings
    try:
        with open("mapping_settings.json", "r", encoding="utf-8") as f:
            custom_settings = json.load(f)
    except FileNotFoundError:
        custom_settings = {}
    except Exception as e:
        messagebox.showerror("Error", f"Failed to load settings: {e}")
def parse_srt_from_content(content):
    """Parse SRT content to extract subtitle components"""
    pattern = re.compile(
        r'(\d+)\s*\n'                           # Subtitle number
        r'(\d{2}:\d{2}:\d{2},\d{3})\s-->\s'     # Start time
        r'(\d{2}:\d{2}:\d{2},\d{3})\s*\n'       # End time
        r'((?:.*(?:\n|$))+?)'                   # Content (possibly multi-line)
        r'(?=\n\d+\s*\n|\Z)',                   # End of block (next subtitle or end of file)
        re.MULTILINE
    )
    
    subtitles = []
    for match in pattern.finditer(content):
        index = match.group(1)
        start = match.group(2)
        end = match.group(3)
        text = match.group(4).strip()
        subtitles.append((index, start, end, text))
    
    return subtitles
def process_output_file(output_path, original_path=None, retry_count=0, max_retries=6):

    try:
        # Create log file if it doesn't exist
        log_file = "translation_log.txt"
        if not os.path.exists(log_file):
            with open(log_file, 'w', encoding='utf-8') as f:
                f.write("Translation log started...\n\n")
        
        # Log processing start
        with open(log_file, 'w', encoding='utf-8') as f:
            f.write(f"Processing file: {output_path}\n")
            
        # Read the output file content
        with open(output_path, 'r', encoding='utf-8') as f:
            content_output = f.read()

        # Remove unwanted characters
        pattern_remove = r'[\[\]「」【】|│》《『⌈√←™˙\*゜・·･⭑.。০、∴∵¨ひ✓€८キ#♡♥★☆$Θ®Ⓡ◎④③②①△▲◆▶�☑■●•১הוהוו〝`´י''~_"""!]+'
        content_output = re.sub(pattern_remove, '', content_output)
            
        # Trim excess content (keep only valid SRT blocks)
        pattern_block = re.compile(
            r'(\d+\s*\n'                           # Subtitle number
            r'\d{2}:\d{2}:\d{2},\d{3}\s-->\s'      # Start time
            r'\d{2}:\d{2}:\d{2},\d{3}\s*\n'        # End time
            r'(?:.*(?:\n|$))+?)',                  # Content (possibly multi-line)
            re.MULTILINE
        )
        
        # Find all subtitle blocks
        match_out = pattern_block.search(content_output)
        if match_out:
            matches_out = list(pattern_block.finditer(content_output))
            content_output = content_output[matches_out[0].start():matches_out[-1].end()]
        
        # Count Chinese characters after cleaning
        count_chinese = len(re.findall(r'[\u4e00-\u9fff]', content_output))
        
        # Count parentheses pairs after cleaning
        matches_parentheses = re.findall(r'\([^)]*\)', content_output)
        count_parentheses = len(matches_parentheses)
        
        # Log the statistics
        with open(log_file, 'a', encoding='utf-8') as f:
            f.write(f"- Chinese characters: {count_chinese}\n")
            f.write(f"- Parentheses pairs: {count_parentheses}\n")
        
        print(f"Processed file: {output_path}")
        print(f"- Chinese characters: {count_chinese}")
        print(f"- Parentheses pairs: {count_parentheses}")
        
        # Parse the cleaned content
        subtitles_target = parse_srt_from_content(content_output)
        
        # Check issues and determine if retry is needed
        needs_retry = False
        retry_reason = ""
        
        # If we have an original file to compare with
        if original_path and os.path.exists(original_path):
            with open(original_path, 'r', encoding='utf-8') as f:
                content_original = f.read()
                
            # Clean the original content too
            content_original = re.sub(pattern_remove, '', content_original)
            match_orig = pattern_block.search(content_original)
            if match_orig:
                matches_orig = list(pattern_block.finditer(content_original))
                content_original = content_original[matches_orig[0].start():matches_orig[-1].end()]
                
            # Parse the original content
            subtitles_original = parse_srt_from_content(content_original)
            
            # Check 1: Line count mismatch
            if len(subtitles_original) != len(subtitles_target):
                needs_retry = True
                retry_reason = f"Line count mismatch: original={len(subtitles_original)}, translated={len(subtitles_target)}"
                with open(log_file, 'a', encoding='utf-8') as f:
                    f.write(f"- {retry_reason}\n")
        
        # Check 2: Too many Chinese characters
        if count_chinese > 30:
            needs_retry = True
            retry_reason = f"Too many Chinese characters: {count_chinese} (limit: 30)"
            with open(log_file, 'a', encoding='utf-8') as f:
                f.write(f"- {retry_reason}\n")
        
        # Check 3: Too many parentheses
        if count_parentheses > 20:
            needs_retry = True
            retry_reason = f"Too many parentheses pairs: {count_parentheses} (limit: 20)"
            with open(log_file, 'a', encoding='utf-8') as f:
                f.write(f"- {retry_reason}\n")
        
        # If retry is needed and we haven't reached max retries
        if needs_retry:
            if retry_count < max_retries:
                with open(log_file, 'a', encoding='utf-8') as f:
                    f.write(f"- Needs retry ({retry_count + 1}/{max_retries}): {retry_reason}\n\n")
                return False, True, retry_reason, retry_reason
            else:
                with open(log_file, 'a', encoding='utf-8') as f:
                    f.write(f"- Maximum retries reached. Last issue: {retry_reason}\n\n")
                return False, False, f"Maximum retries reached. Last issue: {retry_reason}", retry_reason
        
        # If no retry needed, save the formatted content
        with open(output_path, 'w', encoding='utf-8') as f:
            formatted_content = ''
            for sub in subtitles_target:
                formatted_content += f"{sub[0]}\n{sub[1]} --> {sub[2]}\n{sub[3]}\n\n"
            f.write(formatted_content)
        
        with open(log_file, 'a', encoding='utf-8') as f:
            f.write("- File processed successfully\n\n")
        
        return True, False, "File processed successfully", None
            
    except Exception as e:
        print(f"Error processing output file: {e}")
        import traceback
        traceback.print_exc()
        with open("translation_log.txt", 'a', encoding='utf-8') as f:
            f.write(f"- Error: {str(e)}\n\n")
        return False, False, f"Error: {str(e)}", str(e)
# Function to translate file
def translate_file(api_key, srt_content, output_file, translate_status_label, profile_path, api_type, original_file=None, retry_count=0, max_retries=6):
    """
    Translate the SRT file with retry logic, saving each attempt as a numbered file
    """
    try:
        # Create base name for retry files
        base_name, ext = os.path.splitext(output_file)
        
        # Current attempt output file
        current_output = output_file if retry_count == 0 else f"{base_name} {retry_count}{ext}"
        
        if retry_count > 0:
            if translate_status_label:
                translate_status_label.config(text=f"Retry translation attempt {retry_count}/{max_retries}...")
            print(f"Retry translation attempt {retry_count}/{max_retries}...")
        
        target_lang = "en"  # Default language
        file_name = os.path.basename(output_file)
        for key, lang in custom_settings.get("mapping", {}).items():
            if key in file_name:
                target_lang = lang
                break

        # Modify prompt based on retry count and previous issues
        if retry_count > 0:
            prompt = f"{target_lang} (IMPORTANT: Please maintain the exact same number of subtitle entries as the original. Avoid using Chinese characters and minimize parentheses usage):\n\n{srt_content}"
        else:
            prompt = f"{target_lang}:\n\n{srt_content}"
        
        if api_type == "AI Studio":
            # AI Studio API logic
            url = f"https://generativelanguage.googleapis.com/v1beta/models/{custom_settings['model']}:generateContent?key={api_key}"
            headers = {"Content-Type": "application/json"}
            payload = {
                "contents": [
                    {
                        "parts": [
                            {"text": prompt}
                        ]
                    }
                ]
            }

            response = requests.post(url, json=payload, headers=headers)

            if response.status_code == 200:
                response_data = response.json()
                translated_text = response_data["candidates"][0]["content"]["parts"][0]["text"]
            else:
                raise Exception(f"API Error: {response.status_code}, {response.text}")

        elif api_type == "Gemini":
            # Use Gemini Web API
            try:
                # Initialize selenium to get cookies
                user_data_dir, profile_name = split_chrome_profile_path(profile_path)
                if not user_data_dir or not profile_name:
                    raise Exception("Invalid profile path format")
                
                chrome_options = Options()
                chrome_options.add_argument(f"user-data-dir={user_data_dir}")
                chrome_options.add_argument(f"--profile-directory={profile_name}")
                chrome_options.add_argument("--headless")
                
                service = Service(ChromeDriverManager().install())
                driver = webdriver.Chrome(service=service, options=chrome_options)
                
                # Status update in UI
                if translate_status_label:
                    translate_status_label.config(text="Getting cookies...")
                    root = translate_status_label.winfo_toplevel()
                    root.update_idletasks()
                
                driver.get("https://gemini.google.com")
                time.sleep(10)  # Wait for the page to load
                
                cookies = driver.get_cookies()
                secure_1psid = None
                secure_1psidts = None
                
                for cookie in cookies:
                    if cookie['name'] == '__Secure-1PSID':
                        secure_1psid = cookie['value']
                    elif cookie['name'] == '__Secure-1PSIDTS':
                        secure_1psidts = cookie['value']
                
                driver.quit()
                
                if not secure_1psid or not secure_1psidts:
                    raise Exception("Required cookies not found. Please check your Chrome profile.")
                
                # Use the async function with asyncio
                if translate_status_label:
                    translate_status_label.config(text="Translating with Gemini...")
                    root = translate_status_label.winfo_toplevel()
                    root.update_idletasks()
                
                # Create an async function to use GeminiClient
                async def translate_with_gemini():
                    try:
                        client = GeminiClient(secure_1psid, secure_1psidts)
                        await client.init(timeout=400)
                        response = await client.generate_content(prompt=prompt, model=custom_settings['model'])
                        translated_text = response.text
                        await client.close()
                        return translated_text
                    except Exception as e:
                        await client.close()
                        raise e
                
                # Run the async function
                translated_text = asyncio.run(translate_with_gemini())
                
            except Exception as e:
                raise Exception(f"Gemini API error: {str(e)}")

        else:
            raise Exception("Invalid API type selected.")

        # Write translated content to file
        with open(current_output, "w", encoding="utf-8") as f:
            f.write(translated_text)

        # Process output file and check if retry is needed
        success, needs_retry, message, retry_reason = process_output_file(current_output, original_file, retry_count, max_retries)
        
        if needs_retry and retry_count < max_retries:
            # Wait a moment before retrying
            time.sleep(3)
            # Recursive call for retry
            return translate_file(api_key, srt_content, output_file, translate_status_label, profile_path, api_type, 
                                original_file, retry_count + 1, max_retries)
        else:
            return current_output
            
    except Exception as e:
        error_msg = f"Failed to translate file: {str(e)}"
        with open("translation_log.txt", 'a', encoding='utf-8') as f:
            f.write(f"Error in translation: {error_msg}\n\n")
        raise Exception(error_msg)
# Process video function - combines extraction and translation
def process_videos_thread(video_folder, output_folder, status_label, api_key=None, profile_path=None, api_type=None):
    try:
        # Get list of video files
        video_files = get_video_files(video_folder)
        if not video_files:
            messagebox.showerror("Error", "No video files found in the selected folder.")
            status_label.config(text="No video files found")
            return

        status_label.config(text=f"Found {len(video_files)} video files to process")
        
        # Open CapCut
        if not open_capcut():
            messagebox.showerror("Error", "Failed to open CapCut")
            status_label.config(text="Failed to open CapCut")
            return

        # Clean projects folder first
        capcut_path = os.getenv("LOCALAPPDATA") + r"\JianyingPro"
        projects_path = capcut_path + r"\User Data\Projects\com.lveditor.draft"
        project_list = [p for p in os.listdir(projects_path) if p not in ['.recycle_bin', 'root_meta_info.json']]
        
        for project in project_list:
            while True:
                if delete_folder(fr"{projects_path}\{project}") == True or delete_folder(fr"{projects_path}\{project}") == None:
                    break
                time.sleep(1)
        
        # Create output folder if it doesn't exist
        os.makedirs(output_folder, exist_ok=True)
        
        # Process each video
        for i, video_path in enumerate(video_files):
            video_name = os.path.splitext(os.path.basename(video_path))[0]
            status_label.config(text=f"Processing video {i+1}/{len(video_files)}: {video_name}")
            
            # Create new project
            while True:
                try:
                    if pyautogui.locateCenterOnScreen('./assets/create_project.png', confidence=0.8):
                        break
                    time.sleep(1)
                except Exception:
                    continue
            
            if not create_new_project(video_path):
                status_label.config(text=f"Failed to create project for {video_name}. Skipping...")
                continue
            
            # Generate auto subtitles
            if not generate_auto_subtitles():
                status_label.config(text=f"Failed to generate subtitles for {video_name}. Skipping...")
                continue
            
            status_label.config(text=f"Subtitles generated for {video_name}")
            
            # Close project
            if not close_project():
                status_label.config(text=f"Failed to close project for {video_name}")
            
            status_label.config(text=f"Extracting SRT for {video_name}")
            
            # Extract SRT file
            original_srt_file, srt_content = get_srt_file(video_name, output_folder)
            
            # Open original SRT in Subtitle Edit for manual editing first
            open_subtitle_edit(original_srt_file, status_label)
            srt_content = open(original_srt_file, 'r', encoding='utf-8').read()
            
            # Translate if needed
            if api_type and api_type != "None":
                status_label.config(text=f"Translating SRT for {video_name}")
                
                # Determine target language
                target_lang = "en"  # Default language
                for key, lang in custom_settings.get("mapping", {}).items():
                    if key in video_name:
                        target_lang = lang
                        break
                
                # Create translated file path
                translated_file = os.path.join(output_folder, f"{video_name} - copy.srt")
                
                try:
                    # Translate with retry logic
                    result_file = translate_file(api_key, srt_content, translated_file, status_label, profile_path, api_type, 
                                  original_srt_file, 0, 6)  # Start with retry count 0, max 6 retries
                    status_label.config(text=f"Translation completed for {video_name}")
                except Exception as e:
                    status_label.config(text=f"Translation failed for {video_name}: {str(e)}")
            
            # Clean up project folder
            project = [p for p in os.listdir(projects_path) if p not in ['.recycle_bin', 'root_meta_info.json']][0]
            while True:
                if delete_folder(fr"{projects_path}\{project}") == True:
                    break
                time.sleep(1)
        
        status_label.config(text="Process completed")
        messagebox.showinfo("Success", "All videos have been processed and SRTs created/translated.")
    
    except Exception as e:
        status_label.config(text=f"Error: {str(e)}")
        messagebox.showerror("Error", str(e))
        tb = e.__traceback__
        error_message = f"Exception: {e} | "
        while tb is not None:
            filename = tb.tb_frame.f_code.co_filename
            lineno = tb.tb_lineno
            function_name = tb.tb_frame.f_code.co_name
            error_message += f"File: {filename}, Line: {lineno}, in {function_name}\n"
            tb = tb.tb_next
        open("error_log.txt", "a").write(error_message)
# Main GUI


def save_all_settings(videos_folder_entry, output_folder_entry, api_var, api_key_entry, profile_entry, model_var, mapping_text):
    """Save all settings from all tabs at once"""
    try:
        global custom_settings
        
        # Get existing settings or create new dict
        if not custom_settings:
            custom_settings = {}
        
        # Save Extract & Translate tab settings
        custom_settings["videos_folder"] = videos_folder_entry.get()
        custom_settings["output_folder"] = output_folder_entry.get()
        custom_settings["api_type"] = api_var.get()
        custom_settings["api_key"] = api_key_entry.get()
        custom_settings["profile_path"] = profile_entry.get()
        
        # Save Settings tab settings
        custom_settings["model"] = model_var.get()
        
        # Process mapping text
        mapping = {}
        for line in mapping_text.get("1.0", tk.END).splitlines():
            if ":" in line:
                key, value = line.split(":", 1)
                mapping[key.strip()] = value.strip()
        custom_settings["mapping"] = mapping
        
        # Save to file
        with open("mapping_settings.json", "w", encoding="utf-8") as f:
            json.dump(custom_settings, f, ensure_ascii=False, indent=4)
        messagebox.showinfo("Success", "All settings saved to mapping_settings.json")
    except Exception as e:
        messagebox.showerror("Error", f"Failed to save settings: {e}")
def main():
    root = tk.Tk()
    root.title("CapCut SRT Extractor & Translator")
    root.geometry("800x650")

    # Load settings
    load_settings_from_file()

    # Create tabs
    notebook = ttk.Notebook(root)
    notebook.pack(fill='both', expand=True, padx=10, pady=10)
    
    # Tabs
    extract_frame = ttk.Frame(notebook)
    settings_frame = ttk.Frame(notebook)
    
    notebook.add(extract_frame, text="Extract & Translate")
    notebook.add(settings_frame, text="Settings")
    
    # Extract & Translate tab
    tk.Label(extract_frame, text="Videos Folder:").grid(row=0, column=0, padx=5, pady=5, sticky="w")
    videos_folder_entry = tk.Entry(extract_frame, width=50)
    videos_folder_entry.grid(row=0, column=1, padx=5, pady=5)
    tk.Button(extract_frame, text="Browse", command=lambda: select_output_folder(videos_folder_entry)).grid(row=0, column=2, padx=5, pady=5)
    
    # Output folder
    tk.Label(extract_frame, text="Output Folder:").grid(row=1, column=0, padx=5, pady=5, sticky="w")
    output_folder_entry = tk.Entry(extract_frame, width=50)
    output_folder_entry.grid(row=1, column=1, padx=5, pady=5)
    tk.Button(extract_frame, text="Browse", command=lambda: select_output_folder(output_folder_entry)).grid(row=1, column=2, padx=5, pady=5)
    
    # API selection
    tk.Label(extract_frame, text="Translation API:").grid(row=2, column=0, padx=5, pady=5, sticky="w")
    api_var = ttk.Combobox(extract_frame, values=["None", "AI Studio", "Gemini"])
    api_var.grid(row=2, column=1, padx=5, pady=5, columnspan=2)
    api_var.set("None")
    
    # API Key and Profile Path (hidden by default)
    api_key_label = tk.Label(extract_frame, text="API Key:")
    api_key_entry = tk.Entry(extract_frame, width=50, show="*")
    
    profile_label = tk.Label(extract_frame, text="Profile Path:")
    profile_entry = tk.Entry(extract_frame, width=50)
    profile_button = tk.Button(extract_frame, text="Browse", command=lambda: select_profile_file(profile_entry))
    
    # Apply saved settings to UI fields
    if custom_settings:
        if "videos_folder" in custom_settings:
            videos_folder_entry.insert(0, custom_settings["videos_folder"])
        
        if "output_folder" in custom_settings:
            output_folder_entry.insert(0, custom_settings["output_folder"])
        
        if "api_type" in custom_settings:
            api_var.set(custom_settings["api_type"])
        
        if "api_key" in custom_settings:
            api_key_entry.insert(0, custom_settings["api_key"])
        
        if "profile_path" in custom_settings:
            profile_entry.insert(0, custom_settings["profile_path"])
    
    # Status label
    status_label = tk.Label(extract_frame, text="Ready")
    status_label.grid(row=6, column=0, columnspan=3, padx=5, pady=10, sticky="w")
    
    def update_api_fields(event):
        if api_var.get() == "None":
            api_key_label.grid_remove()
            api_key_entry.grid_remove()
            profile_label.grid_remove()
            profile_entry.grid_remove()
            profile_button.grid_remove()
        elif api_var.get() == "Gemini":
            api_key_label.grid_remove()
            api_key_entry.grid_remove()
            profile_label.grid(row=3, column=0, padx=5, pady=5, sticky="w")
            profile_entry.grid(row=3, column=1, padx=5, pady=5)
            profile_button.grid(row=3, column=2, padx=5, pady=5)
        else:  # AI Studio
            profile_label.grid_remove()
            profile_entry.grid_remove()
            profile_button.grid_remove()
            api_key_label.grid(row=3, column=0, padx=5, pady=5, sticky="w")
            api_key_entry.grid(row=3, column=1, padx=5, pady=5)
    
    api_var.bind("<<ComboboxSelected>>", update_api_fields)
    
    # Trigger the update based on loaded settings
    update_api_fields(None)
    
    # Process Videos Button
    extract_button = tk.Button(
        extract_frame, 
        text="Process Videos", 
        command=lambda: threading.Thread(
            target=process_videos_thread, 
            args=(
                videos_folder_entry.get(),
                output_folder_entry.get() or os.path.join(os.path.dirname(os.path.abspath(__file__)), "output"),
                status_label,
                api_key_entry.get() if api_var.get() == "AI Studio" else None,
                profile_entry.get() if api_var.get() == "Gemini" else None,
                api_var.get()
            )
        ).start()
    )
    extract_button.grid(row=5, column=1, padx=5, pady=10)
    
    # Save button for Extract tab
    # save_extract_button.grid(row=5, column=2, padx=5, pady=10, sticky="e")  # Remove this line
    # And remove the Save Settings button from the settings tab
    
    # Create a frame at the bottom for the unified save button
    # Add the unified save button
    
    # Settings tab
    tk.Label(settings_frame, text="Select Model:").grid(row=0, column=0, padx=5, pady=5, sticky="w")
    model_var = ttk.Combobox(settings_frame, width=50, values=["gemini-2.0-flash", "gemini-2.0-flash-thinking", "gemini-2.0-flash-lite", "gemini-1.5-flash", "gemini-2.0-flash-thinking-exp-01-21"])
    model_var.grid(row=0, column=1, padx=5, pady=5)
    
    if custom_settings:
        if "model" in custom_settings:
            model_var.set(custom_settings.get("model", ""))
    
    # Custom mapping
    tk.Label(settings_frame, text="Custom Language Mapping:").grid(row=1, column=0, padx=5, pady=5, sticky="nw")
    tk.Label(settings_frame, text="Format: project_keyword:language_code").grid(row=2, column=1, padx=5, pady=0, sticky="w")
    mapping_text = tk.Text(settings_frame, height=8, width=50)
    mapping_text.grid(row=1, column=1, rowspan=2, padx=5, pady=5)
    
    if custom_settings and "mapping" in custom_settings:
        for key, value in custom_settings.get("mapping", {}).items():
            mapping_text.insert(tk.END, f"{key}:{value}\n")
    
    # Example mappings
    example_frame = ttk.LabelFrame(settings_frame, text="Examples")
    example_frame.grid(row=3, column=0, columnspan=2, padx=5, pady=5, sticky="w")
    
    examples = [
        "your_project_name:prompt"
    ]
    
    for i, example in enumerate(examples):
        tk.Label(example_frame, text=example).grid(row=i, column=0, padx=5, pady=2, sticky="w")
    
    # Save settings button
    tk.Button(
        settings_frame, 
        text="Save All Settings", 
        command=lambda: save_all_settings(
            videos_folder_entry, 
            output_folder_entry, 
            api_var, 
            api_key_entry, 
            profile_entry,
            model_var, 
            mapping_text
        ),
        width=20,
        height=2
    ).grid(row=4, column=1, padx=5, pady=10, sticky="e")
    
    root.mainloop()
if __name__ == "__main__":
    if not os.path.exists("Capcut_SRT"):
        os.makedirs("Capcut_SRT")
    main()
